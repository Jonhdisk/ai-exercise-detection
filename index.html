<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÇ‡∏ö‡∏Å‡∏°‡∏∑‡∏≠</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow-models/2.0.0/pose-detection.min.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 10px; 
            text-align: center; 
            font-family: Arial, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .video-container { 
            position: relative; 
            display: inline-block; 
            margin: 20px 0;
        }
        #inputVideo { 
            display: none; 
        }
        #outputCanvas { 
            position: relative; 
            z-index: 1; 
            border: 3px solid #2196F3; 
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        #countdownOverlay { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(0,0,0,0.9); 
            display: none; 
            justify-content: center; 
            align-items: center; 
            flex-direction: column; 
            z-index: 1000; 
        }
        #countdownNumber { 
            font-size: 6rem; 
            color: #FFD700; 
            font-weight: bold; 
            text-shadow: 0 0 20px rgba(255,215,0,0.5);
        }
        .wave-count { 
            color: #2196F3; 
            font-weight: bold; 
            font-size: 1.2em;
        }
        .info-panel { 
            margin: 20px 0; 
            padding: 20px; 
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); 
            border-radius: 15px; 
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.1);
        }
        .instruction { 
            margin: 20px 0; 
            padding: 20px; 
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); 
            border-radius: 15px; 
            border-left: 5px solid #2196F3;
        }
        .error-message { 
            color: #ff4444; 
            background: linear-gradient(135deg, #ffe6e6 0%, #ffcdd2 100%); 
            padding: 15px; 
            border-radius: 10px; 
            margin: 10px 0; 
            border-left: 5px solid #ff4444;
        }
        .controls { 
            margin: 20px 0; 
        }
        button { 
            padding: 12px 25px; 
            margin: 8px; 
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); 
            color: white; 
            border: none; 
            border-radius: 25px; 
            cursor: pointer; 
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(33,150,243,0.3);
        }
        button:hover { 
            background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%); 
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33,150,243,0.4);
        }
        button:disabled { 
            background: #ccc; 
            cursor: not-allowed; 
            transform: none;
            box-shadow: none;
        }
        .performance-info { 
            font-size: 0.9em; 
            color: #666; 
            margin-top: 15px; 
            padding: 10px;
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        .status-active { background: #4CAF50; }
        .status-inactive { background: #f44336; }
        .status-warning { background: #ff9800; }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .debug-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.1);
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            text-align: left;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ü§ñ ‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÇ‡∏ö‡∏Å‡∏°‡∏∑‡∏≠ AI</h1>
        
        <div id="loading">
            <div class="status-indicator status-warning"></div>
            ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î MoveNet Model...
        </div>
        <div id="errorMessage" class="error-message" style="display: none;"></div>
        
        <div class="controls" style="display: none;" id="controls">
            <button onclick="startCamera()">üé• ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
            <button onclick="stopCamera()">‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á</button>
            <button onclick="resetSystem()">üîÑ ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï</button>
            <button onclick="toggleDebug()">üîß Debug</button>
        </div>
        
        <div class="video-container" id="videoContainer" style="display: none;">
            <video id="inputVideo" autoplay playsinline muted></video>
            <canvas id="outputCanvas"></canvas>
        </div>
        
        <div class="info-panel">
            <div class="status-text" id="statusText">
                <span class="status-indicator status-inactive" id="statusIndicator"></span>
                ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö...
            </div>
            <div style="margin: 10px 0;">
                ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÇ‡∏ö‡∏Å: <span class="wave-count" id="waveCount">0</span> / 3 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á
            </div>
            <div style="margin: 10px 0;">
                ‡∏£‡∏∞‡∏¢‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏°‡∏∑‡∏≠: <span id="handMovement">--</span>
            </div>
            <div style="margin: 10px 0;">
                ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏°‡∏∑‡∏≠: <span id="handStatus">--</span>
            </div>
            <div class="performance-info">
                üìä FPS: <span id="fpsDisplay">--</span> | 
                ‚è±Ô∏è ‡πÄ‡∏ß‡∏•‡∏≤‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•: <span id="processingTime">--</span>ms |
                üéØ Poses ‡∏û‡∏ö: <span id="posesFound">--</span>
            </div>
        </div>
        
        <div class="instruction">
            <h3>üìã ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:</h3>
            <ul style="text-align: left; max-width: 400px; margin: 0 auto;">
                <li>üñêÔ∏è ‡∏¢‡∏∑‡∏ô‡πÉ‡∏´‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏´‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏ï‡πá‡∏°</li>
                <li>‚úã ‡∏¢‡∏Å‡∏°‡∏∑‡∏≠‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏´‡∏ô‡∏∑‡∏≠‡πÑ‡∏´‡∏•‡πà</li>
                <li>üëã ‡πÇ‡∏ö‡∏Å‡∏ã‡πâ‡∏≤‡∏¢-‡∏Ç‡∏ß‡∏≤ 3 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô</li>
                <li>‚è∞ ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ô‡∏±‡∏ö‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</li>
            </ul>
        </div>
        
        <div id="debugInfo" class="debug-info" style="display: none;">
            <strong>Debug Information:</strong><br>
            <div id="debugText">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• debug</div>
        </div>
    </div>

    <!-- Countdown Overlay -->
    <div id="countdownOverlay">
        <div id="countdownNumber">5</div>
        <div style="color: white; font-size: 1.5rem; margin-top: 20px;">‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏ï‡∏±‡∏ß‡πÉ‡∏´‡πâ‡∏û‡∏£‡πâ‡∏≠‡∏°! üöÄ</div>
    </div>

    <script>
        // Global variables
        let detector;
        let video;
        let canvas;
        let ctx;
        let stream;
        let animationId;
        let isRunning = false;
        let debugMode = false;
        
        // Video dimensions
        let videoWidth = 640;
        let videoHeight = 480;
        
        // Performance monitoring
        let lastFrameTime = 0;
        let frameCount = 0;
        let fps = 0;
        let lastFpsUpdate = 0;
        
        // Hand wave detection
        let waveCount = 0;
        let waveState = 'center';
        let lastWaveTime = 0;
        let waveCooldown = 300; // ‡∏•‡∏î‡πÄ‡∏ß‡∏•‡∏≤ cooldown
        let rightWristHistory = [];
        let historyLength = 5; // ‡∏•‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô history
        let waveThreshold = 30; // ‡∏•‡∏î‡∏Ñ‡πà‡∏≤ threshold
        
        // MoveNet keypoints
        const KEYPOINTS = {
            'nose': 0, 'left_eye': 1, 'right_eye': 2, 'left_ear': 3, 'right_ear': 4,
            'left_shoulder': 5, 'right_shoulder': 6, 'left_elbow': 7, 'right_elbow': 8,
            'left_wrist': 9, 'right_wrist': 10, 'left_hip': 11, 'right_hip': 12,
            'left_knee': 13, 'right_knee': 14, 'left_ankle': 15, 'right_ankle': 16
        };
        
        // Debug function
        function debugLog(message) {
            if (debugMode) {
                console.log('DEBUG:', message);
                const debugText = document.getElementById('debugText');
                debugText.innerHTML = message + '<br>' + debugText.innerHTML.split('<br>').slice(0, 9).join('<br>');
            }
        }
        
        function toggleDebug() {
            debugMode = !debugMode;
            document.getElementById('debugInfo').style.display = debugMode ? 'block' : 'none';
        }
        
        // Show/hide error messages
        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            console.error('Error:', message);
        }
        
        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }
        
        // Update status
        function updateStatusText(text, status = 'active') {
            const statusText = document.getElementById('statusText');
            const statusIndicator = document.getElementById('statusIndicator');
            
            statusText.innerHTML = `<span class="status-indicator status-${status}" id="statusIndicator"></span>${text}`;
        }
        
        // Update performance display
        function updatePerformanceDisplay(processingTime, posesFound = 0) {
            frameCount++;
            const now = performance.now();
            
            if (now - lastFpsUpdate > 1000) {
                fps = Math.round(frameCount * 1000 / (now - lastFpsUpdate));
                frameCount = 0;
                lastFpsUpdate = now;
                
                document.getElementById('fpsDisplay').textContent = fps;
            }
            
            document.getElementById('processingTime').textContent = Math.round(processingTime);
            document.getElementById('posesFound').textContent = posesFound;
        }
        
        // Initialize system
        async function initializeSystem() {
            try {
                updateStatusText('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î MoveNet Model...', 'warning');
                debugLog('‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÇ‡∏´‡∏•‡∏î MoveNet model');
                
                // Check if required libraries are loaded
                if (typeof poseDetection === 'undefined') {
                    throw new Error('PoseDetection library not loaded');
                }
                
                const model = poseDetection.SupportedModels.MoveNet;
                const detectorConfig = {
                    modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                    minPoseScore: 0.25,
                    multiPoseMaxDimension: 256
                };
                
                detector = await poseDetection.createDetector(model, detectorConfig);
                debugLog('MoveNet model ‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('controls').style.display = 'block';
                
                updateStatusText('‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à - ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô', 'active');
                
            } catch (error) {
                console.error('Error initializing system:', error);
                showError('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏• AI ‡πÑ‡∏î‡πâ: ' + error.message);
                updateStatusText('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î‡πÇ‡∏°‡πÄ‡∏î‡∏•', 'inactive');
            }
        }
        
        // Start camera
        async function startCamera() {
            try {
                hideError();
                updateStatusText('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á...', 'warning');
                debugLog('‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á');
                
                // Stop existing stream
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                
                const constraints = {
                    video: {
                        facingMode: 'user',
                        width: { ideal: 640, min: 320 },
                        height: { ideal: 480, min: 240 },
                        frameRate: { ideal: 30, max: 60 }
                    }
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                video = document.getElementById('inputVideo');
                canvas = document.getElementById('outputCanvas');
                ctx = canvas.getContext('2d');
                
                video.srcObject = stream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        videoWidth = video.videoWidth;
                        videoHeight = video.videoHeight;
                        
                        // Set canvas size
                        canvas.width = videoWidth;
                        canvas.height = videoHeight;
                        
                        // Set display size
                        const maxWidth = 400;
                        const aspectRatio = videoHeight / videoWidth;
                        const displayWidth = Math.min(maxWidth, videoWidth);
                        const displayHeight = displayWidth * aspectRatio;
                        
                        canvas.style.width = displayWidth + 'px';
                        canvas.style.height = displayHeight + 'px';
                        
                        debugLog(`‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô: ${videoWidth}x${videoHeight}`);
                        
                        document.getElementById('videoContainer').style.display = 'block';
                        isRunning = true;
                        
                        updateStatusText('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÇ‡∏ö‡∏Å‡∏°‡∏∑‡∏≠...', 'active');
                        detectPose();
                        resolve();
                    };
                });
                
            } catch (error) {
                console.error('Camera error:', error);
                let errorMessage = '‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage = '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Å‡∏•‡πâ‡∏≠‡∏á';
                }
                
                showError(errorMessage);
                updateStatusText('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÑ‡∏î‡πâ', 'inactive');
            }
        }
        
        // Stop camera
        function stopCamera() {
            isRunning = false;
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            if (video) {
                video.srcObject = null;
            }
            
            document.getElementById('videoContainer').style.display = 'none';
            updateStatusText('‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô', 'inactive');
            debugLog('‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô');
        }
        
        // Reset system
        function resetSystem() {
            waveCount = 0;
            waveState = 'center';
            lastWaveTime = 0;
            rightWristHistory = [];
            
            document.getElementById('waveCount').textContent = '0';
            document.getElementById('handMovement').textContent = '--';
            document.getElementById('handStatus').textContent = '--';
            
            updateStatusText('‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô - ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö', 'active');
            debugLog('‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏∞‡∏ö‡∏ö');
        }
        
        // Draw skeleton
        function drawSkeleton(keypoints) {
            // Draw connections
            const connections = [
                [5, 6], [5, 7], [7, 9], [6, 8], [8, 10], // Arms
                [5, 11], [6, 12], [11, 12], // Torso
                [11, 13], [13, 15], [12, 14], [14, 16] // Legs
            ];
            
            ctx.strokeStyle = '#00FF00';
            ctx.lineWidth = 3;
            
            connections.forEach(([i, j]) => {
                const kp1 = keypoints[i];
                const kp2 = keypoints[j];
                
                if (kp1 && kp2 && kp1.score > 0.3 && kp2.score > 0.3) {
                    ctx.beginPath();
                    ctx.moveTo(kp1.x, kp1.y);
                    ctx.lineTo(kp2.x, kp2.y);
                    ctx.stroke();
                }
            });
            
            // Draw keypoints
            keypoints.forEach((keypoint, index) => {
                if (keypoint.score > 0.3) {
                    let color = '#00FF00';
                    let size = 6;
                    
                    if (index === KEYPOINTS.right_wrist) {
                        color = '#FF0000';
                        size = 10;
                    } else if (index === KEYPOINTS.right_shoulder) {
                        color = '#0000FF';
                        size = 8;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(keypoint.x, keypoint.y, size, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Add white border
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }
        
        // Detect hand wave
        function detectHandWave(keypoints) {
            const rightWrist = keypoints[KEYPOINTS.right_wrist];
            const rightShoulder = keypoints[KEYPOINTS.right_shoulder];
            
            if (!rightWrist || !rightShoulder || rightWrist.score < 0.4 || rightShoulder.score < 0.4) {
                document.getElementById('handStatus').textContent = '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏°‡∏∑‡∏≠/‡πÑ‡∏´‡∏•‡πà';
                return false;
            }
            
            // Check if hand is raised
            const handRaised = rightWrist.y < rightShoulder.y;
            document.getElementById('handStatus').textContent = handRaised ? '‡∏¢‡∏Å‡∏°‡∏∑‡∏≠‡πÅ‡∏•‡πâ‡∏ß' : '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏¢‡∏Å‡∏°‡∏∑‡∏≠';
            
            if (!handRaised) {
                updateStatusText('‡∏¢‡∏Å‡∏°‡∏∑‡∏≠‡∏Ç‡∏ß‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÇ‡∏ö‡∏Å', 'warning');
                return false;
            }
            
            const currentTime = Date.now();
            
            // Add to history
            rightWristHistory.push({
                x: rightWrist.x,
                y: rightWrist.y,
                time: currentTime
            });
            
            // Keep only recent history
            if (rightWristHistory.length > historyLength) {
                rightWristHistory.shift();
            }
            
            if (rightWristHistory.length < historyLength) {
                return false;
            }
            
            // Calculate movement
            const oldPos = rightWristHistory[0];
            const newPos = rightWristHistory[rightWristHistory.length - 1];
            const horizontalMovement = Math.abs(newPos.x - oldPos.x);
            const scaledThreshold = waveThreshold * (videoWidth / 640);
            
            document.getElementById('handMovement').textContent = `${Math.round(horizontalMovement)}px (‡∏ï‡πâ‡∏≠‡∏á: ${Math.round(scaledThreshold)}px)`;
            
            // Check for wave motion
            if (horizontalMovement > scaledThreshold && currentTime - lastWaveTime > waveCooldown) {
                const direction = newPos.x > oldPos.x ? 'right' : 'left';
                debugLog(`‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß: ${direction}, ‡∏£‡∏∞‡∏¢‡∏∞: ${horizontalMovement}px`);
                
                if ((waveState === 'center' && direction === 'right') ||
                    (waveState === 'right' && direction === 'left') ||
                    (waveState === 'left' && direction === 'right')) {
                    
                    if (waveState === 'left' && direction === 'right') {
                        waveCount++;
                        lastWaveTime = currentTime;
                        
                        document.getElementById('waveCount').textContent = waveCount;
                        updateStatusText(`‡πÇ‡∏ö‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà ${waveCount}! ${waveCount < 3 ? `‡∏≠‡∏µ‡∏Å ${3 - waveCount} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á` : '‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô!'}`, 'active');
                        debugLog(`‡πÇ‡∏ö‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà ${waveCount}`);
                        
                        if (waveCount >= 3) {
                            completeHandWaveDetection();
                            return true;
                        }
                    }
                    
                    waveState = direction;
                }
                
                // Clear history after movement
                rightWristHistory = [];
            }
            
            // Draw wave visualization
            drawWaveVisualization(rightWrist, rightShoulder, horizontalMovement, scaledThreshold);
            return false;
        }
        
        // Draw wave visualization
        function drawWaveVisualization(rightWrist, rightShoulder, movement, threshold) {
            // Draw arm line
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(rightShoulder.x, rightShoulder.y);
            ctx.lineTo(rightWrist.x, rightWrist.y);
            ctx.stroke();
            
            // Draw wrist circle
            ctx.fillStyle = movement > threshold ? '#FF0000' : '#00FF00';
            ctx.beginPath();
            ctx.arc(rightWrist.x, rightWrist.y, 15, 0, 2 * Math.PI);
            ctx.fill();
            
            // Draw movement indicator
            if (movement > threshold) {
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.arc(rightWrist.x, rightWrist.y, 30, 0, 2 * Math.PI);
                ctx.stroke();
            }
            
            // Draw text
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            
            const statusText = '‡πÇ‡∏ö‡∏Å‡∏ã‡πâ‡∏≤‡∏¢-‡∏Ç‡∏ß‡∏≤';
            ctx.strokeText(statusText, rightWrist.x, rightWrist.y - 50);
            ctx.fillText(statusText, rightWrist.x, rightWrist.y - 50);
        }
        
        // Complete detection
        function completeHandWaveDetection() {
            updateStatusText('‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô! üéâ', 'active');
            setTimeout(startCountdown, 1000);
        }
        
        // Start countdown
        function startCountdown() {
            const overlay = document.getElementById('countdownOverlay');
            const numberElement = document.getElementById('countdownNumber');
            
            overlay.style.display = 'flex';
            let count = 5;
            
            const countdownInterval = setInterval(() => {
                numberElement.textContent = count;
                count--;
                
                if (count < 0) {
                    clearInterval(countdownInterval);
                    numberElement.textContent = '‡πÄ‡∏£‡∏¥‡πà‡∏°!';
                    numberElement.style.color = '#00FF00';
                    
                    setTimeout(() => {
                        overlay.style.display = 'none';
                        numberElement.style.color = '#FFD700';
                        resetSystem();
                        alert('üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô! ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°‡πÑ‡∏î‡πâ‡πÅ‡∏•‡πâ‡∏ß');
                    }, 1500);
                }
            }, 1000);
        }
        
        // Main detection loop
        async function detectPose() {
            if (!isRunning || !detector) return;
            
            const startTime = performance.now();
            
            try {
                if (video.readyState >= 2) {
                    const poses = await detector.estimatePoses(video);
                    
                    // Clear canvas and draw video
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    let posesFound = poses.length;
                    
                    if (poses.length > 0) {
                        const pose = poses[0];
                        const keypoints = pose.keypoints;
                        
                        // Scale keypoints to canvas size
                        const scaledKeypoints = keypoints.map(kp => ({
                            ...kp,
                            x: kp.x * videoWidth,
                            y: kp.y * videoHeight
                        }));
                        
                        drawSkeleton(scaledKeypoints);
                        detectHandWave(scaledKeypoints);
                        
                        debugLog(`‡∏û‡∏ö pose: ${posesFound}, keypoints: ${keypoints.length}`);
                    } else {
                        // Draw "no pose detected" message
                        ctx.fillStyle = '#FF0000';
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center';
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 2;
                        ctx.strokeText('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏á', canvas.width / 2, canvas.height / 2);
                        ctx.fillText('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏á', canvas.width / 2, canvas.height / 2);
                        
                        document.getElementById('handStatus').textContent = '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ó‡πà‡∏≤‡∏ó‡∏≤‡∏á';
                    }
                    
                    const processingTime = performance.now() - startTime;
                    updatePerformanceDisplay(processingTime, posesFound);
                }
            } catch (error) {
                console.error('Detection error:', error);
                debugLog('Detection error: ' + error.message);
            }
            
            // Continue detection
            setTimeout(() => {
                animationId = requestAnimationFrame(detectPose);
            }, 50); // ~20 FPS
        }
        
        // Initialize when page loads
        window.addEventListener('load', initializeSystem);
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', stopCamera);
        
        // Handle page visibility change
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isRunning) {
                debugLog('Tab hidden - pausing detection');
                isRunning = false;
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            } else if (!document.hidden && stream && !isRunning) {
                debugLog('Tab visible - resuming detection');
                isRunning = true;
                detectPose();
            }
        });
    </script>
</body>
</html>
